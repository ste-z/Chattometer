{"version":3,"file":"background.js","mappings":";;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://chattometer/./src/scripts/background.js"],"sourcesContent":["// Listen for messages from the content script\nchrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n  if (request.action === \"calculateImpact\") {\n    // --- Log request received ---\n    console.log(\"Background script received 'calculateImpact' request:\", JSON.stringify(request, null, 2));\n\n    const requestBody = {\n        // FIXME: use different model names based on request.modelName if needed\n        model: \"gpt-4o\",\n        tokens: request.tokens\n    };\n\n    // --- Log request body being sent to backend ---\n    console.log(\"Sending request to backend:\", JSON.stringify(requestBody, null, 2));\n\n\n    // Perform the fetch request\n    fetch('https://chattometer.onrender.com/calculate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(requestBody),\n    })\n    .then(response => {\n      if (!response.ok) {\n        // If response is not ok, create an error object to send back\n        return response.text().then(text => {\n          // --- Log backend error response ---\n          console.error(`Backend responded with error: ${response.status}`, text);\n          throw new Error(`Backend Error: ${response.status} - ${text}`); // More informative error\n        });\n      }\n      return response.json(); // Parse JSON if response is ok\n    })\n    .then(data => {\n      // --- Log successful data from backend ---\n      console.log(\"Received successful data from backend:\", JSON.stringify(data, null, 2));\n      // --- Compute average impacts for cumulative tracking ---\n      const avgEnergyWh = ((data.impacts.energy_kWh.min + data.impacts.energy_kWh.max) / 2) * 1000;\n      const avgGhgG = ((data.impacts.gwp_kgCO2eq.min + data.impacts.gwp_kgCO2eq.max) / 2) * 1000;\n      // Update cumulative impacts only for new tokens since last processed count\n      chrome.storage.local.get(['cumulativeRequests', 'processedTokens'], (result) => {\n        const cum = result.cumulativeRequests || {};\n        const tokensMap = result.processedTokens || {};\n        // Create a consistent key by using origin + pathname (ignore search/hash)\n        const urlObj = new URL(request.url);\n        const chatKey = `${urlObj.origin}${urlObj.pathname}`;  \n        // Initialize cumulative entry with tokens and timestamp\n        if (!cum[chatKey]) {\n          cum[chatKey] = {\n            energyWh: 0,\n            ghgG: 0,\n            tokens: 0,\n            timestamp: new Date(request.timestamp).toISOString()\n          };\n        }\n        const lastTokens = tokensMap[chatKey] || 0;\n        const newTokens = request.tokens;\n        const deltaTokens = newTokens - lastTokens;\n        if (deltaTokens > 0) {\n          const energyPerToken = avgEnergyWh / newTokens;\n          const ghgPerToken = avgGhgG / newTokens;\n          cum[chatKey].energyWh += energyPerToken * deltaTokens;\n          cum[chatKey].ghgG += ghgPerToken * deltaTokens;\n          // Update cumulative tokens\n          cum[chatKey].tokens = newTokens;\n          tokensMap[chatKey] = newTokens;\n        }\n        chrome.storage.local.set({ cumulativeRequests: cum, processedTokens: tokensMap });\n      });\n\n      // Store impact data and request info for popup\n      chrome.storage.local.get(['lastImpactDataMap', 'lastRequestMap'], (maps) => {\n        const impactMap = maps.lastImpactDataMap || {};\n        const reqMap = maps.lastRequestMap || {};\n        const urlObj = new URL(request.url);\n        const chatKey = `${urlObj.origin}${urlObj.pathname}`;\n        // Update maps for this chat\n        impactMap[chatKey] = data;\n        reqMap[chatKey] = { model: request.modelName, tokens: request.tokens, timestamp: request.timestamp, url: request.url };\n        // Persist maps\n        chrome.storage.local.set({ lastImpactDataMap: impactMap, lastRequestMap: reqMap }, () => {\n          console.log('Saved impact data map and request map to storage');\n          sendResponse({ success: true, data: data });\n        });\n      });\n    })\n    .catch(error => {\n      // --- Log fetch/processing error ---\n      console.error('Error during fetch or processing in background:', error);\n      // Send an error object back to the content script\n      console.log(\"Sending error response to content script.\");\n      sendResponse({ success: false, error: error.message });\n    });\n\n    // Return true to indicate that the response will be sent asynchronously\n    return true;\n  }\n});\n\nconsole.log(\"Chattometer background script loaded\");\n\n// Listen for SPA navigation events and notify content scripts to reinitialize\nchrome.webNavigation.onHistoryStateUpdated.addListener((details) => {\n  chrome.tabs.sendMessage(details.tabId, { action: 'reinitializeChattometer' }, () => {\n    if (chrome.runtime.lastError) {\n      console.warn('Error sending reinit message to content script:', chrome.runtime.lastError.message);\n    }\n  });\n});\n"],"names":[],"sourceRoot":""}